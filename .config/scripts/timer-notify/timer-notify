#!/usr/bin/env bash

TIMER_DIR="$HOME/.config/timer-notify"
mkdir -p "$TIMER_DIR"

help() {
  cat <<EOF
Usage: timer-notify [duration] [unit] [message]  Set timer with notification
       timer-notify --cancel [ID]               Cancel a specific timer
       timer-notify --list                      List active timers
       timer-notify --pause [ID]                 Pause a specific timer
       timer-notify --resume [ID]                Resume a paused timer

Systemd-based timer notifications that work across sessions and reboots.

Time units can be specified (ex. "30 minutes", "2 hours", "1 day").
If no unit is given, the duration is treated as seconds.

Units: s|sec|second(s), m|min|minute(s), h|hr|hour(s), d|day(s)
Example: timer-notify 30 minutes "study time over\!"

Made by Dioxair
EOF
}

set-timer() {
  local value=$1
  local unit=$2
  local seconds
  local message

  case "$unit" in
    s|sec|secs|second|seconds)
      seconds=$value
      shift 2
      ;;
    m|min|mins|minute|minutes)
      seconds=$((value * 60))
      shift 2
      ;;
    h|hr|hrs|hour|hours)
      seconds=$((value * 3600))
      shift 2
      ;;
    d|day|days)
      seconds=$((value * 86400))
      shift 2
      ;;
    *)
      seconds=$value
      shift 1
      ;;
  esac

  message="$*"

  if ! [[ "$seconds" =~ ^[1-9][0-9]*$ ]]; then
    echo "Error: Invalid or zero duration specified." >&2
    exit 1
  fi
  if [[ -z "$message" ]]; then
    echo "Error: A message is required." >&2
    exit 1
  fi

  local id=$(date +%s%N | sha1sum | cut -c1-8)
  local sanitized="timer-${id}"
  local now=$(date +%s)
  local end_ts=$((now + seconds))

  systemd-run --user \
    --unit="$sanitized" \
    --on-active="+${seconds}seconds" \
    --description="Timer: $message" \
    --timer-property=AccuracySec=1us \
    systemctl --user start "timer-notify@${id}.service"

  printf "%s:%s:%s:%s\n" "$id" "${message//:/\\:}" "$seconds" "$end_ts" \
    >> "$TIMER_DIR/active-timers"

  echo "Timer set for $seconds seconds (ID: $id)"
}

list-timers() {
  local now=$(date +%s)

  # Active timers
  echo "Active timers:"
  if [[ -s "$TIMER_DIR/active-timers" ]]; then
    while IFS=: read -r id rawmsg dur end_ts; do
      local message=${rawmsg//\\:/\:}
      if (( end_ts > now )); then
        local rem=$((end_ts - now))
        printf "  ID: %s | Message: %s | Remaining: %ds\n" \
          "$id" "$message" "$rem"
      else
        # expired behind the scenes, remove it
        sed -i "/^${id}:/d" "$TIMER_DIR/active-timers"
      fi
    done < "$TIMER_DIR/active-timers"
  else
    echo "  (none)"
  fi

  echo
  # Paused timers
  echo "Paused timers:"
  if [[ -s "$TIMER_DIR/paused-timers" ]]; then
    while IFS=: read -r id remaining rawmsg; do
      local message=${rawmsg//\\:/\:}
      printf "  ID: %s | Message: %s | Paused with %ds remaining\n" \
        "$id" "$message" "$remaining"
    done < "$TIMER_DIR/paused-timers"
  else
    echo "  (none)"
  fi
}

pause-timer() {
  local id=$1
  local line
  line=$(grep "^${id}:" "$TIMER_DIR/active-timers") || {
    echo "Timer $id not found or already paused"
    return 1
  }

  IFS=: read -r _ rawmsg dur end_ts <<< "$line"
  local message=${rawmsg//\\:/\:}
  local now=$(date +%s)
  local remaining=$((end_ts - now))

  if (( remaining <= 0 )); then
    echo "Timer $id already expired"
    # clean up stale entry
    sed -i "/^${id}:/d" "$TIMER_DIR/active-timers"
    return 1
  fi

  # stop the timer unit
  systemctl --user stop "timer-${id}.timer"

  # remove from active and append to paused
  sed -i "/^${id}:/d" "$TIMER_DIR/active-timers"
  printf "%s:%s:%s\n" "$id" "$remaining" "$message" \
    >> "$TIMER_DIR/paused-timers"

  echo "Paused timer $id ($remaining seconds left)"
}

resume-timer() {
  local id=$1
  local line
  line=$(grep "^${id}:" "$TIMER_DIR/paused-timers") || {
    echo "Timer $id not found in paused timers"
    return 1
  }

  IFS=: read -r _ remaining rawmsg <<< "$line"
  local message=${rawmsg//\\:/\:}

  # remove from paused
  sed -i "/^${id}:/d" "$TIMER_DIR/paused-timers"

  # compute new end timestamp
  local now=$(date +%s)
  local new_end=$((now + remaining))

  # re-run the transient timer
  systemd-run --user \
    --unit="timer-${id}" \
    --on-active="+${remaining}seconds" \
    --description="Timer: $message" \
    --timer-property=AccuracySec=1us \
    systemctl --user start "timer-notify@${id}.service"

  # back into active, with updated timestamps
  printf "%s:%s:%s:%s\n" "$id" "${message//:/\\:}" "$remaining" "$new_end" \
    >> "$TIMER_DIR/active-timers"

  echo "Resumed timer $id ($remaining seconds left)"
}

cancel-timer() {
  local id=$1
  local unit="timer-${id}.timer"

  if grep -q "^$id:" "$TIMER_DIR/active-timers"; then
    # systemctl whines about the unit not being loaded, but the
    # timer still stops so its whatever i guess i just silence it here
    # (yes i know this is bad practice)
    systemctl --user stop "$unit"         2>/dev/null || true
    systemctl --user disable "$unit"      2>/dev/null || true
    systemctl --user reset-failed "$unit" 2>/dev/null || true

    sed -i "/^$id:/d" "$TIMER_DIR/active-timers"
    echo "Canceled timer $id"
  else
    echo "Timer $id not found"
  fi
}

case $1 in
  -h|--help)    help ;;
  --list)       list-timers ;;
  --cancel)     cancel-timer "$2" ;;
  --pause)      pause-timer "$2" ;;
  --resume)     resume-timer "$2" ;;
  [0-9]*)       set-timer "$@" ;;
  *)            help; exit 1 ;;
esac
